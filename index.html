<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Endless Driving – Highest Score Wins</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#111923; --accent:#38bdf8; --muted:#96a3b3; --good:#22c55e; --bad:#ef4444;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:#e6edf3;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif}
    h1{font-size:1.1rem;margin:0 0 .5rem 0;color:#d6e2f0;font-weight:700}
    .wrap{display:grid;gap:16px;grid-template-columns:320px 1fr;max-width:1100px;margin:24px auto;padding:0 16px}
    .panel{background:var(--panel);border:1px solid #1f2a36;border-radius:14px;padding:14px;box-shadow:0 8px 30px rgba(0,0,0,.25)}
    .controls label{display:block;font-size:.85rem;color:#c9d4e1;margin:10px 0 6px}
    .controls input{width:100%;padding:8px 10px;border-radius:10px;border:1px solid #2a394a;background:#0c141d;color:#e6edf3}
    .controls .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .btns{display:flex;gap:8px;margin-top:12px}
    button{appearance:none;border:1px solid #24475b;background:#0f1a24;color:#e6f2ff;padding:8px 12px;border-radius:10px;font-weight:600;cursor:pointer}
    button.primary{border-color:#1f9ecb;background:#102838}
    button:disabled{opacity:.55;cursor:not-allowed}
    .hint{font-size:.8rem;color:var(--muted);margin-top:10px;line-height:1.4}
    .gameShell{display:grid;grid-template-columns:1fr auto 1fr;align-items:start}
    .hud{display:flex;gap:12px;justify-content:center;margin-bottom:8px}
    .chip{background:#0e1620;border:1px solid #263649;padding:6px 10px;border-radius:999px;font-variant-numeric:tabular-nums}
    .chip.good{border-color:#235b3c;color:#b6ffd0}
    .chip.bad{border-color:#63343a;color:#ffc8c8}
    canvas{background:#0b1016;border:1px solid #1f2a36;border-radius:14px;box-shadow:0 10px 40px rgba(0,0,0,.35)}
    .legend{font-size:.8rem;color:var(--muted);text-align:center;margin-top:6px}
    .roadMark{position:relative}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel controls">
      <h1>Setup</h1>
      <label for="playerSpeed">Your speed (px/s)</label>
      <input id="playerSpeed" type="number" min="60" max="1200" step="10" value="320">

      <div class="row">
        <div>
          <label for="enemySpeed">Enemies speed (px/s)</label>
          <input id="enemySpeed" type="number" min="60" max="1400" step="10" value="260">
        </div>
        <div>
          <label for="spawnRate">Enemies per second</label>
          <input id="spawnRate" type="number" min="0.2" max="8" step="0.1" value="1.2">
        </div>
      </div>

      <div class="row">
        <div>
          <label for="hearts">Hearts (lives)</label>
          <input id="hearts" type="number" min="1" max="9" step="1" value="3">
        </div>
        <div>
          <label for="invuln">Invuln on hit (ms)</label>
          <input id="invuln" type="number" min="0" max="2000" step="50" value="600">
        </div>
      </div>

      <div class="btns">
        <button id="startBtn" class="primary">Start</button>
        <button id="pauseBtn" disabled>Pause</button>
        <button id="resumeBtn" disabled>Resume</button>
        <button id="resetBtn">Reset</button>
      </div>
      <div class="hint">
        Controls: ← → or A D to steer. P to pause/resume. Colliding costs a heart. When hearts hit 0, game over. Highest score is saved.
      </div>
    </div>

    <div class="panel game">
      <div class="hud">
        <div class="chip" id="scoreChip">Score: 0</div>
        <div class="chip good" id="hiChip">High: 0</div>
        <div class="chip bad" id="heartsChip">Hearts: 3</div>
      </div>
      <div class="gameShell">
        <div></div>
        <div>
          <canvas id="game" width="420" height="640" aria-label="Driving game area"></canvas>
          <div class="legend">Highest score wins. Tweak settings on the left.</div>
        </div>
        <div></div>
      </div>
    </div>
  </div>

  <script>
  (function() {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // UI elements
    const el = id => document.getElementById(id);
    const startBtn = el('startBtn'), pauseBtn = el('pauseBtn'), resumeBtn = el('resumeBtn'), resetBtn = el('resetBtn');
    const scoreChip = el('scoreChip'), hiChip = el('hiChip'), heartsChip = el('heartsChip');
    const inPlayerSpeed = el('playerSpeed'), inEnemySpeed = el('enemySpeed'), inSpawnRate = el('spawnRate');
    const inHearts = el('hearts'), inInvuln = el('invuln');

    // Game state
    let state = null; // set by reset()
    const rand = (min, max) => Math.random() * (max - min) + min;

    function reset() {
      const hi = +localStorage.getItem('driving_highscore') || 0;
      state = {
        running: false,
        paused: false,
        w: canvas.width,
        h: canvas.height,
        t: 0,
        lastSpawn: 0,
        score: 0,
        high: hi,
        hearts: +inHearts.value || 3,
        invulnFor: +inInvuln.value || 600,
        invulnUntil: 0,
        player: {
          x: canvas.width/2 - 18,
          y: canvas.height - 120,
          w: 36,
          h: 64,
          speed: +inPlayerSpeed.value || 320,
        },
        enemies: [],
        enemySpeed: +inEnemySpeed.value || 260,
        spawnRate: +inSpawnRate.value || 1.2, // per second
        keys: {left:false,right:false},
      };
      updateHUD();
      drawSplash('Press Start');
    }

    function start() {
      if (state.running) return;
      state.running = true;
      state.paused = false;
      startBtn.disabled = true;
      pauseBtn.disabled = false;
      resumeBtn.disabled = true;
      state.t = performance.now();
      requestAnimationFrame(loop);
    }

    function pause() {
      if (!state.running || state.paused) return;
      state.paused = true;
      pauseBtn.disabled = true;
      resumeBtn.disabled = false;
      drawSplash('Paused');
    }

    function resume() {
      if (!state.running || !state.paused) return;
      state.paused = false;
      pauseBtn.disabled = false;
      resumeBtn.disabled = true;
      state.t = performance.now();
      requestAnimationFrame(loop);
    }

    function gameOver() {
      state.running = false;
      pauseBtn.disabled = true;
      resumeBtn.disabled = true;
      startBtn.disabled = false;
      if (state.score > state.high) {
        state.high = state.score;
        localStorage.setItem('driving_highscore', String(state.high));
      }
      drawSplash('Game Over');
      updateHUD();
    }

    function loop(now) {
      if (!state.running) return;
      if (state.paused) return;
      const dt = Math.min(0.033, (now - state.t) / 1000); // clamp for stability
      state.t = now;

      update(dt);
      render();
      requestAnimationFrame(loop);
    }

    function update(dt) {
      // scoring
      state.score += Math.floor(60 * dt); // ~1 point per frame at 60fps

      // player movement
      const p = state.player;
      const move = p.speed * dt;
      if (state.keys.left) p.x -= move;
      if (state.keys.right) p.x += move;
      p.x = Math.max(12, Math.min(state.w - p.w - 12, p.x));

      // enemy spawning
      state.lastSpawn += dt;
      const interval = 1 / Math.max(0.05, state.spawnRate);
      if (state.lastSpawn >= interval) {
        state.lastSpawn = 0;
        spawnEnemy();
      }

      // move enemies
      const es = state.enemySpeed * dt;
      for (const e of state.enemies) {
        e.y += es;
      }
      // remove offscreen
      state.enemies = state.enemies.filter(e => e.y < state.h + 40);

      // collisions
      if (performance.now() > state.invulnUntil) {
        for (const e of state.enemies) {
          if (rectsOverlap(p, e)) {
            state.hearts -= 1;
            state.invulnUntil = performance.now() + state.invulnFor;
            if (state.hearts <= 0) {
              gameOver();
            }
            break;
          }
        }
      }

      updateHUD();
    }

    function spawnEnemy() {
      const lanePadding = 12;
      const ew = rand(28, 44), eh = rand(42, 70);
      const ex = rand(lanePadding, state.w - lanePadding - ew);
      const color = `hsl(${Math.floor(rand(0,360))} 70% 60%)`;
      state.enemies.push({x:ex, y:-eh, w:ew, h:eh, color});
    }

    function rectsOverlap(a,b){
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }

    function render() {
      const w = state.w, h = state.h;
      // background road
      ctx.clearRect(0,0,w,h);
      // road gradient
      const g = ctx.createLinearGradient(0,0,0,h);
      g.addColorStop(0,'#0a1018');
      g.addColorStop(1,'#0b1824');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,w,h);

      // lane markings
      ctx.strokeStyle = '#1b2a3a';
      ctx.lineWidth = 4;
      for (let i=1;i<=4;i++){ // light lane guides
        const x = (w/5) * i;
        ctx.beginPath();
        ctx.moveTo(x,0); ctx.lineTo(x,h);
        ctx.stroke();
      }

      // dashed center stripes scrolling with score
      ctx.setLineDash([14,16]);
      ctx.lineDashOffset = - (state.score % 30);
      ctx.strokeStyle = '#33506e';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(w/2,0); ctx.lineTo(w/2,h);
      ctx.stroke();
      ctx.setLineDash([]);

      // enemies
      for (const e of state.enemies) {
        drawCar(e.x,e.y,e.w,e.h,e.color);
      }

      // player (blink when invuln)
      const blinking = performance.now() < state.invulnUntil;
      const alpha = blinking ? (0.4 + 0.6*Math.sin(performance.now()/50)) : 1;
      ctx.save();
      ctx.globalAlpha = alpha;
      drawCar(state.player.x, state.player.y, state.player.w, state.player.h, '#38bdf8');
      ctx.restore();
    }

    function drawCar(x,y,w,h,color){
      // body
      ctx.fillStyle = color;
      roundRect(ctx,x,y,w,h,10,true,false);
      // windshield
      ctx.fillStyle = 'rgba(255,255,255,.15)';
      roundRect(ctx,x+6,y+8,w-12,h/3,6,true,false);
      // wheels
      ctx.fillStyle = '#0c0c0c';
      ctx.fillRect(x-4,y+8,6,18);
      ctx.fillRect(x+w-2,y+8,6,18);
      ctx.fillRect(x-4,y+h-26,6,18);
      ctx.fillRect(x+w-2,y+h-26,6,18);
    }

    function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
      if (typeof radius === 'number') radius = {tl: radius, tr: radius, br: radius, bl: radius};
      ctx.beginPath();
      ctx.moveTo(x + radius.tl, y);
      ctx.lineTo(x + width - radius.tr, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
      ctx.lineTo(x + width, y + height - radius.br);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
      ctx.lineTo(x + radius.bl, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
      ctx.lineTo(x, y + radius.tl);
      ctx.quadraticCurveTo(x, y, x + radius.tl, y);
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    function drawSplash(text){
      render();
      ctx.fillStyle = 'rgba(0,0,0,.55)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#e6edf3';
      ctx.font = '700 28px system-ui,Segoe UI,Roboto';
      ctx.textAlign = 'center';
      ctx.fillText(text, canvas.width/2, canvas.height/2 - 6);
      ctx.font = '400 14px system-ui,Segoe UI,Roboto';
      ctx.fillStyle = '#a9b8c7';
      ctx.fillText('Press Resume or Start to continue', canvas.width/2, canvas.height/2 + 20);
    }

    function updateHUD(){
      scoreChip.textContent = 'Score: ' + state.score;
      hiChip.textContent = 'High: ' + Math.max(state.high, state.score);
      heartsChip.textContent = 'Hearts: ' + state.hearts;
    }

    // Input
    window.addEventListener('keydown', (e)=>{
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') state.keys.left = true;
      if (e.code === 'ArrowRight' || e.code === 'KeyD') state.keys.right = true;
      if (e.code === 'KeyP') (state.paused?resume():pause());
    });
    window.addEventListener('keyup', (e)=>{
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') state.keys.left = false;
      if (e.code === 'ArrowRight' || e.code === 'KeyD') state.keys.right = false;
    });

    // Buttons
    startBtn.addEventListener('click', start);
    pauseBtn.addEventListener('click', pause);
    resumeBtn.addEventListener('click', resume);
    resetBtn.addEventListener('click', ()=>{ reset(); });

    // Changing settings mid-run takes effect immediately
    inPlayerSpeed.addEventListener('input', ()=> state.player.speed = +inPlayerSpeed.value || 320);
    inEnemySpeed.addEventListener('input', ()=> state.enemySpeed = +inEnemySpeed.value || 260);
    inSpawnRate.addEventListener('input', ()=> state.spawnRate = +inSpawnRate.value || 1.2);
    inHearts.addEventListener('input', ()=> state.hearts = Math.max(0, +inHearts.value||0));
    inInvuln.addEventListener('input', ()=> state.invulnFor = Math.max(0, +inInvuln.value||0));

    // Init
    reset();
  })();
  </script>
</body>
</html>
